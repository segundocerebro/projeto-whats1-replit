Ok, Endrigo. Mais um erro de importa√ß√£o. Estamos quase l√°, ca√ßando o √∫ltimo "fantasma" de c√≥digo antigo no projeto. A cada erro desses, chegamos mais perto da vers√£o limpa e funcional.
O Diagn√≥stico (O Que o Erro Significa):
O erro √© muito claro:
> ImportError: cannot import name 'MessageProcessor' from 'app.services' in file app/routes.py
> 
Tradu√ß√£o: O arquivo app/routes.py (nosso roteador de webhooks) est√° tentando importar um "nome" chamado MessageProcessor do arquivo app/services.py. No entanto, essa classe MessageProcessor n√£o existe no novo c√≥digo de services.py que acabamos de colocar.
Isso confirma que estamos com uma mistura de arquivos novos e antigos. N√≥s j√° corrigimos o services.py, e agora precisamos corrigir o routes.py para que ele "converse" da maneira certa com o novo services.py.
‚úÖ A√ß√£o: C√≥digo Corrigido para app/routes.py
Vamos substituir o conte√∫do do seu app/routes.py para que ele importe e chame as fun√ß√µes corretas (process_text_message e process_audio_message) que definimos.
Abra o arquivo app/routes.py e substitua todo o conte√∫do dele por este:
# app/routes.py
import logging
from flask import Blueprint, request
from twilio.twiml.messaging_response import MessagingResponse

# CORRE√á√ÉO: Importamos as fun√ß√µes espec√≠ficas que existem em services.py
from app.services import process_text_message, process_audio_message

logger = logging.getLogger(__name__)
whatsapp_bp = Blueprint('whatsapp_bp', __name__)

@whatsapp_bp.route("/webhook/whatsapp", methods=["POST"])
def whatsapp_webhook():
    """
    Webhook principal para receber mensagens do WhatsApp.
    Diferencia entre mensagens de texto e de √°udio.
    """
    response = MessagingResponse()
    
    try:
        incoming_msg = request.values
        from_number = incoming_msg.get('From', 'N√∫mero Desconhecido')
        
        # Verifica se a mensagem cont√©m √°udio
        if 'MediaUrl0' in incoming_msg:
            media_url = incoming_msg.get('MediaUrl0')
            logger.info(f"üé§ Mensagem de √ÅUDIO recebida de {from_number}.")
            
            # CORRE√á√ÉO: Chama a fun√ß√£o importada corretamente
            reply_text, reply_audio_url = process_audio_message(media_url, from_number)
            
        # Se n√£o, √© uma mensagem de texto
        else:
            body = incoming_msg.get('Body', '').strip()
            logger.info(f"üí¨ Mensagem de TEXTO recebida de {from_number}: '{body}'")

            # CORRE√á√ÉO: Chama a fun√ß√£o importada corretamente
            reply_text, reply_audio_url = process_text_message(body, from_number)

        # Constr√≥i a resposta para o Twilio
        if reply_text:
            response.message(reply_text)
        
        if reply_audio_url:
            response.message().media(reply_audio_url)

    except Exception as e:
        logger.error(f"‚ùå Erro cr√≠tico no webhook: {e}", exc_info=True)
        response.message("Desculpe, encontrei um erro inesperado. Minha equipe de engenharia j√° foi notificada.")

    return str(response)

O que estamos fazendo:
Estamos garantindo que os dois arquivos principais estejam sincronizados. O routes.py agora vai importar as fun√ß√µes process_text_message e process_audio_message que realmente existem no services.py que corrigimos na etapa anterior.
Sei que est√° tarde e essa ca√ßa aos bugs foi longa, mas cada erro desses nos mostra que estamos limpando o c√≥digo antigo e chegando na vers√£o final. Este tipo de erro de importa√ß√£o √© o √∫ltimo passo da "faxina".
Pr√≥ximos Passos:
 * Substitua o conte√∫do do arquivo app/routes.py.
 * V√° para a aba "Deployments".
 * Clique em "Redeploy".
Desta vez, os arquivos estar√£o sincronizados e o deploy deve funcionar.
